1.物件可以被攤平也可以展開。
2.如果只有自己寫的 Java 城市會用到這些資料：加以序列化(Serialization)。
3.如果資料需要被其他程式引用：以其他程式可以解析的特殊字元分隔格式寫到檔案中。
4.儲存狀況的兩種辦法：
A：把物件寫入檔案中(例如：有精靈、矮人、魔法師三種人物物件)。
B：寫入純文字檔。
5.將序列化物件寫入檔案的步驟：
A：建構出 FileOutPutSteram 。
B：製作 ObjectOutputStreem 。
C：寫入物件。
D：關閉 ObjectOutputStreem 。
6.介紹資料如何變成檔案的過程。
7.當物件被序列化時，該物件的實體變數也會被序列化。且所有被參考的物件也會被序列化，這些動作都是自動執行的。
8.序列化程序會把物件版圖上的所有東西儲存起來。被物件的實體變數所參考的鎖又物件也都會被序列化。
9.如果要讓 Class 能夠被序列化就必須實作 Serializable。
10.整個物件版圖必須都正確的序列化，不然其中一個失敗全部失敗。例如 Duck 物件不能被序列化，那 Pond 物件也就不能被序列化。
11.如果某實體變數不能或不應該被序列化，就把它標示為 transient (暫態)的。
12.Deserialization 還原物件的步驟：
A：建構出 FileInputSteram 。
B：製作 ObjectInputStreem 。
C：讀取物件。
D：轉換物件型別。
E：關閉 ObjectInputStreem 。
13.解序列化的步驟：
A：物件從 Stream 中讀出來。
B：JVM 透過儲存的資訊判別出物件的 class 型別。
C：JVM 嘗試尋找與載入物件的 class。如果 JVM 找不到或無法載入該 class ，則 JVM 會拋出例外。
D：新的物件會被配置在 heap 上，但 constructor 不會執行!很明顯的，這樣會把物件的狀態抹去又變成全新的，而這不是我們想要的結果。我們需要物件回到儲存時點的狀態。
E：如果物件在繼承樹上有個不可序列化的祖先 class，則該不可序列化 class 以及在他之上的 class 的 constructor (就算是可序列化也一樣)就會執行。一但 constructor 連鎖啟動之後將無法停止。也就是說從第一個不可序列化的 superclass 開始，全部都會重心初始狀態。
F：物件的實體變數會被還原成序列化時點的狀態值。transient 變數會被指派 null 的物件參考或者 primitive 的預設 0、false 值。
14.將字串寫入文字檔。
15.可以對 File 物件做的事情：
A：建構出代表縣存檔案的 File 物件。
B：建立新的目錄。
C：列出目錄下的內容。
D：取得檔案或目錄的絕對路徑。
E：刪除目錄或檔案(成功會回傳true)。
16.緩衝區的介紹。
17.讀取文字檔。
18.解析字串使用 String 的 split() 解析。
19.使用 Version ID：序列化的識別的步驟與介紹：
A：使用 Serialver 工具來取得版本 ID。
B：把輸出拷貝到 class 上。
C：在修改 class 的時候要確定修改程式的後果!例如說新的 Dog 要能夠處理舊的 Dog 解序列化之後新加入變數的預設值。
